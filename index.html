<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Retro Snake</title>
  <style>
    :root {
      --bg: #050308;
      --panel-bg: #11111a;
      --accent: #00ff9d;
      --accent-soft: #8affd1;
      --danger: #ff4b5c;
      --text: #f2f2f2;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: "Courier New", monospace;
      background:
        radial-gradient(circle at top, #252545 0, transparent 50%),
        radial-gradient(circle at bottom, #1a3a3a 0, transparent 55%),
        var(--bg);
      color: var(--text);
    }

    .wrapper {
      display: flex;
      gap: 20px;
      padding: 20px 24px;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 16px;
      box-shadow:
        0 0 0 1px rgba(0, 255, 157, 0.1),
        0 20px 40px rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(8px);
    }

    .panel {
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 12px 16px;
      min-width: 220px;
      background: linear-gradient(145deg, #050509, #131320);
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    .panel h1 {
      margin: 0 0 10px;
      font-size: 20px;
      letter-spacing: 4px;
      text-transform: uppercase;
      color: var(--accent-soft);
      text-shadow: 0 0 6px rgba(0, 255, 157, 0.7);
    }

    .score {
      margin-top: 4px;
      font-size: 16px;
    }

    .score span {
      color: var(--accent);
    }

    .hint {
      margin-top: 18px;
      font-size: 13px;
      line-height: 1.4;
      opacity: 0.8;
    }

    .hint code {
      background: rgba(255, 255, 255, 0.05);
      padding: 1px 4px;
      border-radius: 4px;
      font-size: 12px;
    }

    .controls-list {
      margin-top: 14px;
      font-size: 12px;
      opacity: 0.85;
      line-height: 1.5;
    }

    .controls-list div {
      margin-bottom: 2px;
    }

    .label {
      color: var(--accent-soft);
    }

    .crt {
      position: relative;
      padding: 14px;
      background: radial-gradient(circle at top left, #262649 0, #050308 60%);
      border-radius: 18px;
      border: 2px solid rgba(0, 0, 0, 0.8);
      box-shadow:
        0 0 0 1px rgba(0, 255, 157, 0.15),
        0 40px 60px rgba(0, 0, 0, 0.85);
      overflow: hidden;
    }

    .crt::before {
      content: "";
      pointer-events: none;
      position: absolute;
      inset: 0;
      background-image: linear-gradient(
        rgba(255, 255, 255, 0.06) 1px,
        transparent 1px
      );
      background-size: 100% 2px;
      mix-blend-mode: soft-light;
      opacity: 0.4;
    }

    .crt::after {
      content: "";
      pointer-events: none;
      position: absolute;
      inset: 0;
      background: radial-gradient(
        ellipse at top,
        rgba(255, 255, 255, 0.1),
        transparent 60%
      );
      opacity: 0.4;
      mix-blend-mode: screen;
    }

    canvas {
      display: block;
      border-radius: 6px;
      image-rendering: pixelated;
      box-shadow:
        0 0 0 1px rgba(0, 0, 0, 0.8),
        0 0 25px rgba(0, 255, 157, 0.25);
      background: #000;
    }

    .message {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 0 20px;
      pointer-events: none;
      font-size: 15px;
      text-shadow:
        0 0 6px rgba(0, 0, 0, 0.8),
        0 0 8px rgba(0, 255, 157, 0.6);
      color: var(--accent-soft);
    }

    @media (max-width: 720px) {
      .wrapper {
        flex-direction: column;
      }
      .panel {
        min-width: 0;
      }
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <div class="panel">
      <div>
        <h1>RETRO SNAKE</h1>
        <div class="score">
          Score: <span id="score">0</span>
        </div>
        <div class="hint">
          Use <code>← ↑ ↓ →</code> or <code>W A S D</code> to move.<br />
          Press <code>P</code> to pause.
        </div>
        <div class="controls-list">
          <div><span class="label">Grow:</span> eat the red squares</div>
          <div><span class="label">Lose:</span> hit your own tail</div>
          <div><span class="label">Restart:</span> press <code>R</code></div>
        </div>
      </div>
    </div>

    <div class="crt">
      <canvas id="game" width="400" height="400"></canvas>
      <div id="message" class="message"></div>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      const message = document.getElementById("message");
      const scoreEl = document.getElementById("score");

      const gridSize = 20;
      const tileCount = canvas.width / gridSize;

      let snake;
      let direction;
      let nextDirection;
      let food;
      let score;
      let playing;
      let gameOver;
      let lastTime;
      let tickInterval;
      let accumulator;
      let paused;

      function resetGame() {
        snake = [
          { x: 10, y: 10 },
          { x: 9, y: 10 },
          { x: 8, y: 10 }
        ];
        direction = { x: 1, y: 0 };
        nextDirection = { ...direction };
        spawnFood();
        score = 0;
        scoreEl.textContent = score;
        playing = false;
        gameOver = false;
        paused = false;
        accumulator = 0;
        tickInterval = 100; // ms per step
        lastTime = performance.now();
        message.textContent = "Press any arrow key or W A S D to start";
      }

      function spawnFood() {
        let valid = false;
        while (!valid) {
          const x = Math.floor(Math.random() * tileCount);
          const y = Math.floor(Math.random() * tileCount);
          valid =
            !snake || !snake.some((s) => s.x === x && s.y === y);
          if (valid) {
            food = { x, y };
          }
        }
      }

      function setDirection(dx, dy) {
        if (gameOver) return;
        // Prevent immediate reverse
        if (-dx === direction.x && -dy === direction.y) return;
        nextDirection = { x: dx, y: dy };

        if (!playing) {
          playing = true;
          message.textContent = "";
          lastTime = performance.now();
          requestAnimationFrame(loop);
        }
      }

      window.addEventListener("keydown", (e) => {
        switch (e.key) {
          case "ArrowUp":
          case "w":
          case "W":
            setDirection(0, -1);
            break;
          case "ArrowDown":
          case "s":
          case "S":
            setDirection(0, 1);
            break;
          case "ArrowLeft":
          case "a":
          case "A":
            setDirection(-1, 0);
            break;
          case "ArrowRight":
          case "d":
          case "D":
            setDirection(1, 0);
            break;
          case "p":
          case "P":
            if (gameOver) return;
            paused = !paused;
            message.textContent = paused ? "Paused" : "";
            if (!paused) {
              lastTime = performance.now();
              requestAnimationFrame(loop);
            }
            break;
          case "r":
          case "R":
            if (gameOver) {
              resetGame();
              draw();
            }
            break;
        }
      });

      function loop(timestamp) {
        if (!playing || paused) return;

        const delta = timestamp - lastTime;
        lastTime = timestamp;
        accumulator += delta;

        while (accumulator >= tickInterval) {
          step();
          accumulator -= tickInterval;
        }

        draw();

        if (!gameOver) {
          requestAnimationFrame(loop);
        }
      }

      function step() {
        direction = nextDirection;

        const head = {
          x: snake[0].x + direction.x,
          y: snake[0].y + direction.y
        };

        // Wrap around edges
        if (head.x < 0) head.x = tileCount - 1;
        if (head.x >= tileCount) head.x = 0;
        if (head.y < 0) head.y = tileCount - 1;
        if (head.y >= tileCount) head.y = 0;

        // Self collision
        if (snake.some((seg) => seg.x === head.x && seg.y === head.y)) {
          gameOver = true;
          playing = false;
          message.textContent = "Game over. Press R to restart";
          return;
        }

        snake.unshift(head);

        if (head.x === food.x && head.y === food.y) {
          score += 10;
          scoreEl.textContent = score;
          spawnFood();
          // Slight speed up
          tickInterval = Math.max(50, tickInterval - 2);
        } else {
          snake.pop();
        }
      }

      function draw() {
        // Background
        ctx.fillStyle = "#050608";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Grid
        ctx.strokeStyle = "rgba(255,255,255,0.05)";
        ctx.lineWidth = 1;
        for (let i = 0; i <= tileCount; i++) {
          ctx.beginPath();
          ctx.moveTo(i * gridSize, 0);
          ctx.lineTo(i * gridSize, canvas.height);
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(0, i * gridSize);
          ctx.lineTo(canvas.width, i * gridSize);
          ctx.stroke();
        }

        // Food
        if (food) {
          ctx.fillStyle = "#ff4b5c";
          ctx.fillRect(
            food.x * gridSize + 2,
            food.y * gridSize + 2,
            gridSize - 4,
            gridSize - 4
          );
        }

        // Snake
        for (let i = 0; i < snake.length; i++) {
          const seg = snake[i];
          const isHead = i === 0;
          ctx.fillStyle = isHead ? "#9be564" : "#4de38a";
          ctx.fillRect(
            seg.x * gridSize + 1,
            seg.y * gridSize + 1,
            gridSize - 2,
            gridSize - 2
          );
        }

        // Glow
        ctx.globalCompositeOperation = "lighter";
        for (let i = 0; i < snake.length; i++) {
          const seg = snake[i];
          ctx.beginPath();
          ctx.arc(
            seg.x * gridSize + gridSize / 2,
            seg.y * gridSize + gridSize / 2,
            gridSize / 2,
            0,
            Math.PI * 2
          );
          ctx.fillStyle = "rgba(120,255,160,0.08)";
          ctx.fill();
        }
        ctx.globalCompositeOperation = "source-over";
      }

      resetGame();
      draw();
    })();
  </script>
</body>
</html>
